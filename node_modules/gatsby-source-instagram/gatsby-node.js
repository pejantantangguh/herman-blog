"use strict";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const _ = require(`lodash`);

const crypto = require(`crypto`);

const normalize = require(`./normalize`);

const _require = require(`./instagram`),
      apiInstagramPosts = _require.apiInstagramPosts,
      scrapingInstagramPosts = _require.scrapingInstagramPosts,
      apiInstagramHashtags = _require.apiInstagramHashtags,
      scrapingInstagramHashtags = _require.scrapingInstagramHashtags,
      scrapingInstagramUser = _require.scrapingInstagramUser;

const defaultOptions = {
  type: `account`
};

function getInstagramPosts(_x) {
  return _getInstagramPosts.apply(this, arguments);
}

function _getInstagramPosts() {
  _getInstagramPosts = _asyncToGenerator(function* (options) {
    let data;

    if (options.access_token && options.instagram_id) {
      data = yield apiInstagramPosts(options);
    } else {
      data = yield scrapingInstagramPosts(options);
    }

    return data;
  });
  return _getInstagramPosts.apply(this, arguments);
}

function getInstagramHashtags(_x2) {
  return _getInstagramHashtags.apply(this, arguments);
}

function _getInstagramHashtags() {
  _getInstagramHashtags = _asyncToGenerator(function* (options) {
    let data;

    if (options.access_token && options.instagram_id) {
      data = yield apiInstagramHashtags(options);
    } else {
      data = yield scrapingInstagramHashtags(options);
    }

    return data;
  });
  return _getInstagramHashtags.apply(this, arguments);
}

function getInstagramUser(_x3) {
  return _getInstagramUser.apply(this, arguments);
}

function _getInstagramUser() {
  _getInstagramUser = _asyncToGenerator(function* (options) {
    const data = yield scrapingInstagramUser(options);
    return [data];
  });
  return _getInstagramUser.apply(this, arguments);
}

function createPostNode(datum, params) {
  return {
    type: params.type,
    username: params.type === `hashtag` ? params.hashtag : datum.username || datum.owner.username,
    id: datum.shortcode,
    parent: `__SOURCE__`,
    internal: {
      type: `InstaNode`
    },
    children: [],
    likes: _.get(datum, `edge_liked_by.count`) || datum.like_count,
    caption: _.get(datum, `edge_media_to_caption.edges[0].node.text`) || datum.caption,
    thumbnails: datum.thumbnail_resources,
    mediaType: datum.__typename || datum.media_type,
    preview: datum.display_url || datum.thumbnail_url || datum.media_url,
    original: datum.display_url || datum.media_url,
    timestamp: datum.taken_at_timestamp || new Date(datum.timestamp).getTime() / 1000,
    dimensions: datum.dimensions,
    comments: _.get(datum, `edge_media_to_comment.count`) || datum.comments_count
  };
}

function createUserNode(datum, params) {
  return {
    type: params.type,
    id: datum.id,
    full_name: datum.full_name,
    biography: datum.biography,
    edge_followed_by: datum.edge_followed_by,
    edge_follow: datum.edge_follow,
    profile_pic_url: datum.profile_pic_url,
    profile_pic_url_hd: datum.profile_pic_url_hd,
    username: datum.username,
    internal: {
      type: `InstaUserNode`
    }
  };
}

function processDatum(datum, params) {
  const node = params.type === `user-profile` ? createUserNode(datum, params) : createPostNode(datum, params); // Get content digest of node. (Required field)

  const contentDigest = crypto.createHash(`md5`).update(JSON.stringify(node)).digest(`hex`);
  node.internal.contentDigest = contentDigest;
  return node;
}

exports.sourceNodes =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* ({
    actions,
    store,
    cache,
    createNodeId
  }, options) {
    const createNode = actions.createNode,
          touchNode = actions.touchNode;

    const params = _objectSpread({}, defaultOptions, options);

    let data;

    if (params.type === `account`) {
      data = yield getInstagramPosts(params);
    } else if (params.type === `hashtag`) {
      data = yield getInstagramHashtags(params);
    } else if (params.type === `user-profile`) {
      data = yield getInstagramUser(params);
    } else {
      console.warn(`Unknown type for gatsby-source-instagram: ${params.type}`);
    } // Process data into nodes.


    if (data) {
      return Promise.all(data.map(
      /*#__PURE__*/
      function () {
        var _ref2 = _asyncToGenerator(function* (datum) {
          const res = yield normalize.downloadMediaFile({
            datum: processDatum(datum, params),
            store,
            cache,
            createNode,
            createNodeId,
            touchNode
          });
          createNode(res);
        });

        return function (_x6) {
          return _ref2.apply(this, arguments);
        };
      }()));
    }
  });

  return function (_x4, _x5) {
    return _ref.apply(this, arguments);
  };
}();